# ==============================================================================
# HAUPTKONFIGURATION (config.yaml) - KURZANLEITUNG
# ==============================================================================
#
# Dieses Dokument steuert das gesamte Verhalten der P&ID Analyse Suite.
# WICHTIG: Die Einrückung (Leerzeichen) ist in YAML entscheidend und definiert die Struktur!
#
# --- AUFBAU & ZUSAMMENSPIEL ---
#
# 1. paths: Definiert alle Dateipfade, die das Programm intern nutzt.
#
# 2. models: Definiert, WELCHE KI-Modelle ("Mitarbeiter") prinzipiell verfügbar sind.
#
# 3. strategies: Definiert, WIE die Mitarbeiter zu Teams ("Projektpläne") für eine
#    komplette Analyse zusammengestellt werden. Jeder Modellname hier MUSS exakt
#    so in der 'models'-Sektion existieren. Dies sind die STRATEGIEN für den CLI-Runner.
#
# 4. training_camp: Gibt dem Trainings-Orchestrator seine Anweisungen. Der Unterpunkt
#    'strategies_and_models' ist die To-Do-Liste und referenziert die NAMEN aus
#    der 'strategies'-Sektion. Dieser Block kommt DIREKT UNTER 'strategies'.
#
# 5. logic_parameters: Die "Stellschrauben" der KI. Hier werden alle Schwellenwerte,
#    Zähler und technischen Parameter gesteuert. Der Unterpunkt 'cgm_main_components'
#    definiert, welche Komponenten als "Hauptkomponenten" für die Abstraktion dienen.
#
# 6. prompts: Die exakten Arbeitsanweisungen (Prompts) für die KI-Agenten. Diese
#    kommen ganz am Ende der Datei.
# 
# 7. Einrückungsbeispiel
#paths:
  # ... Ihre Pfade ...
#models:
  # ... Ihre Modelle ...
#strategies:
  # ... Ihre Strategien ...
#training_camp:
  # ... Ihr Trainingslager ...
#logic_parameters:
  # ... Ihre Logik-Parameter ...
  #cgm_main_components:
    # ... Ihre CGM Hauptkomponenten ...
#prompts:
# ==============================================================================

# Pfade zu den Konfigurationsdateien und -verzeichnissen
paths:
  element_type_list: "element_type_list.json"
  learning_db: "training_data/learning_db.json"
  temp_symbol_dir: "temp_symbols_for_embeddings"
  # NEU: Verzeichnis für den LLM-Disk-Cache. Wird relativ zum Projekt-Root interpretiert.
  llm_cache_dir: ".pni_analyzer_cache"
  learned_symbols_images_dir: "training_data/learned_symbols_images"
  # Pretraining symbols directory (PDF collections, legend symbols, etc.)
  pretraining_symbols: "training_data/pretraining_symbols"
  # Viewshots directory (visual references for LLM prompts)
  viewshot_examples_dir: "training_data/viewshot_examples"

# Definition aller verfügbaren Modelle, die von der GUI und dem CLI genutzt werden
models:
  "Google Gemini 2.5 Pro":
    id: "gemini-2.5-pro"
    access_method: "gemini"
    location: "us-central1"
    description: "Googles Top-Modell für höchste Genauigkeit bei komplexen Diagrammen. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung
      top_p: 0.1                # Very deterministic - schmale Verteilung für konsistente Ergebnisse
      top_k: 1                  # Most deterministic - nur Top-Token für maximale Konsistenz
      max_output_tokens: 16384  # CRITICAL FIX: Increased from 8192 to 16384 to prevent truncation (MAX_TOKENS)
      candidate_count: 1        # Single response für Geschwindigkeit (optional: 2-3 für Best-of-N)
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 2.5 Flash":
    id: "gemini-2.5-flash"
    access_method: "gemini"
    location: "us-central1"
    description: "Guter Kompromiss aus Geschwindigkeit und Qualität für Standardanalysen. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung
      top_p: 0.1                # Very deterministic - schmale Verteilung für konsistente Ergebnisse
      top_k: 1                  # Most deterministic - nur Top-Token für maximale Konsistenz
      max_output_tokens: 8192   # Gemini 2.5 Flash Standard-Limit (nicht 65530)
      candidate_count: 1        # Single response für Geschwindigkeit (optional: 2-3 für Best-of-N)
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 2.0 Flash":
    id: "gemini-2.0-flash"
    access_method: "gemini"
    location: "us-central1"
    description: "Ein schnelles und kostengünstiges Modell der 2.0-Generation. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung
      top_p: 0.1                # Very deterministic - schmale Verteilung für konsistente Ergebnisse
      top_k: 1                  # Most deterministic - nur Top-Token für maximale Konsistenz
      max_output_tokens: 8192   # Standard-Limit für Gemini 2.0 Modelle
      candidate_count: 1        # Single response für Geschwindigkeit
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 2.0 Flash-Lite":
    id: "gemini-2.0-flash-lite"
    access_method: "gemini"
    location: "us-central1"
    description: "Kosteneffizientes Modell mit großem Kontextfenster. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung
      top_p: 0.1                # Very deterministic - schmale Verteilung für konsistente Ergebnisse
      top_k: 1                  # Most deterministic - nur Top-Token für maximale Konsistenz
      max_output_tokens: 8192   # Standard-Limit für Gemini 2.0 Modelle
      candidate_count: 1        # Single response für Geschwindigkeit
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 2.5 Flash-Lite (Preview)":
    id: "gemini-2.5-flash-lite-preview-06-17"
    access_method: "gemini"
    location: "us-central1"
    description: "Neuestes, extrem schnelles Preview-Modell, ideal für schnelle Iterationen. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung
      top_p: 0.1                # Very deterministic - schmale Verteilung für konsistente Ergebnisse
      top_k: 1                  # Most deterministic - nur Top-Token für maximale Konsistenz
      max_output_tokens: 8192   # Gemini 2.5 Flash-Lite Standard-Limit (nicht 65530)
      candidate_count: 1        # Single response für Geschwindigkeit
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 1.5 Flash":
    id: "gemini-1.5-flash"
    access_method: "gemini"
    location: "us-central1"
    description: "Schnelles und kosteneffizientes Gemini-Modell. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung (reduced from 0.1)
      top_p: 0.1                # Very deterministic - schmale Verteilung (reduced from 0.95)
      top_k: 1                  # Most deterministic - nur Top-Token (reduced from 40)
      max_output_tokens: 8192   # Standard-Limit für Gemini 1.5 Modelle
      candidate_count: 1        # Single response für Geschwindigkeit
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "Google Gemini 1.5 Pro":
    id: "gemini-1.5-pro"
    access_method: "gemini"
    location: "us-central1"
    description: "Leistungsstarkes Gemini-Modell für komplexe Aufgaben. Optimiert für präzise Symbolerkennung."
    generation_config:
      temperature: 0.0          # Deterministic - maximale Präzision für Symbolerkennung (reduced from 0.1)
      top_p: 0.1                # Very deterministic - schmale Verteilung (reduced from 0.95)
      top_k: 1                  # Most deterministic - nur Top-Token (reduced from 40)
      max_output_tokens: 8192   # Standard-Limit für Gemini 1.5 Modelle
      candidate_count: 1        # Single response für Geschwindigkeit
      response_mime_type: "application/json"  # Erzwingt strukturierte JSON-Ausgabe
  "MultiModal Embedding (Image)":
      # Dies ist das dedizierte MultiModal Embedding Model von Vertex AI.
      # Es hat KEINE "generation_config" im klassischen Sinne, da es Embeddings und nicht Text generiert.
      id: "multimodalembedding@001" # Dies ist die korrekte ID für direkte Bild-Embeddings
      access_method: "vertex_ai_multimodal_embedding" # Expliziter Access Method für dieses Modell
      location: "us-central1" # Standort für das Embedding-Modell
      description: "Vertex AI's dediziertes MultiModal Embedding Model für direkte Bild-Embeddings."

  # Definition verschiedener Analyse-Strategien für den CLI-Runner (Möglichkeit für Mischstrategien mit verschiedenen Modellen)
strategies:
  # STRATEGY 1: QUALITY-FOCUSED (RECOMMENDED) - Beste Qualität für professionelle Projekte
  # Optimiert für: Komplexe P&IDs, hohe Genauigkeitsanforderungen
  # Geschwindigkeit: ~15-30 Minuten pro Diagramm
  # CRITICAL: Pro für Meta/Legend (Phase 1) - gesamte Pipeline basiert darauf!
  quality_focused:
    swarm_model: "Google Gemini 2.5 Flash"  # Flash ist ausreichend für Element-Erkennung (viele Tiles)
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Verbindungen (höchste Qualität)
    detail_model: "Google Gemini 2.5 Pro"  # Pro für bessere Detail-Erkennung
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend für Linien-Vektorisierung (CV-basiert)
    correction_model: "Google Gemini 2.5 Pro"  # Pro für besseres Reasoning bei Korrekturen
    critic_model_name: "Google Gemini 2.5 Pro"  # Pro für bessere Kritik-Qualität
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # STRATEGY 2: BALANCED (DEFAULT) - Guter Kompromiss zwischen Qualität und Geschwindigkeit
  # Optimiert für: Standard P&IDs, gute Qualität bei akzeptabler Geschwindigkeit
  # Geschwindigkeit: ~10-20 Minuten pro Diagramm
  # CRITICAL: Pro für Meta/Legend (Phase 1) - gesamte Pipeline basiert darauf!
  optimal_swarm_monolith:
    swarm_model: "Google Gemini 2.5 Flash"  # Flash für Geschwindigkeit bei vielen Tiles
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Verbindungen (immer Pro!)
    detail_model: "Google Gemini 2.5 Flash"  # Flash für Fallback
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Pro"  # Pro für besseres Reasoning
    critic_model_name: "Google Gemini 2.5 Pro"  # Pro für bessere Kritik
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # STRATEGY 3: SIMPLE PID - Optimiert für einfache P&IDs
  # Optimiert für: Einfache Diagramme, schnelle Analyse
  # Geschwindigkeit: ~5-15 Minuten pro Diagramm
  # CRITICAL: Pro für Meta/Legend (Phase 1) - gesamte Pipeline basiert darauf!
  simple_pid_strategy:
    swarm_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (keine Flash-Lite mehr)
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Verbindungen
    detail_model: "Google Gemini 2.5 Pro"  # Pro für bessere Präzision
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Pro"  # Pro für besseres Reasoning
    critic_model_name: "Google Gemini 2.5 Pro"  # Pro für bessere Kritik
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # STRATEGY 3.5: SIMPLE WHOLE IMAGE - Beste Strategie für einfache P&IDs
  # CRITICAL: Bewiesen durch MONOLITH_ANALYSIS.md - Swarm (Tiles) ist bei einfachen Bildern schlechter
  # Optimiert für: Einfache Diagramme, maximale Genauigkeit mit starkem Modell auf ganzem Bild
  # Geschwindigkeit: ~3-10 Minuten pro Diagramm (schneller als Swarm, da nur 1 LLM-Call)
  # Strategie: Ein einzelner Aufruf mit starkem Modell auf dem ganzen Bild (keine Quadranten, keine Tiles)
  # CRITICAL: Pro für Meta/Legend (Phase 1) - gesamte Pipeline basiert darauf!
  simple_whole_image:
    use_swarm_analysis: false  # CRITICAL: Swarm deaktiviert (Tiles sind bei einfachen Bildern schlechter)
    use_monolith_analysis: true  # Monolith aktiviert
    use_fusion: false  # Keine Fusion nötig (nur Monolith)
    use_self_correction_loop: true  # Self-Correction für Qualität
    use_normalization_engine: true  # Wichtig, um "S" -> "pipe" zu fangen
    monolith_whole_image: true  # CRITICAL: Analysiere ganzes Bild, keine Quadranten
    swarm_model: "Google Gemini 2.5 Flash"  # Nicht verwendet (use_swarm_analysis: false)
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Starkes Modell für ganzes Bild
    detail_model: "Google Gemini 2.5 Pro"  # Pro für bessere Präzision
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Pro"  # Pro für besseres Reasoning
    critic_model_name: "Google Gemini 2.5 Pro"  # Pro für bessere Kritik
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # STRATEGY 4: ULTRA-FAST (EXPERIMENTAL) - Maximale Geschwindigkeit, reduzierte Qualität
  # ⚠️ WARNUNG: Nur für schnelle Tests oder wenn Qualität weniger wichtig ist
  # Optimiert für: Schnelle Iterationen, Tests, Prototyping
  # Geschwindigkeit: ~5-10 Minuten pro Diagramm
  # NOTE: Flash-Lite ist hier auskommentiert, aber als Option verfügbar
  # CRITICAL: Auch hier Pro für Meta/Legend (Phase 1) - zu wichtig für Kompromisse!
  ultra_fast:
    swarm_model: "Google Gemini 2.5 Flash"  # Flash statt Flash-Lite (bessere Qualität)
    # swarm_model: "Google Gemini 2.5 Flash-Lite (Preview)"  # OPTION: Uncomment für maximale Geschwindigkeit (reduzierte Qualität)
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro bleibt auch hier (Qualität wichtiger!)
    detail_model: "Google Gemini 2.5 Flash"  # Flash für Geschwindigkeit
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Flash"  # Flash für Geschwindigkeit (reduzierte Qualität)
    critic_model_name: "Google Gemini 2.5 Flash"  # Flash für Geschwindigkeit
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro auch hier (Phase 1 zu wichtig!)
  
  # STRATEGY 4: HYBRID FUSION - Swarm + Monolith + Fusion (alte default_flash)
  # Optimiert für: Maximale Qualität durch Kombination beider Analyzer
  # Geschwindigkeit: ~10-20 Minuten pro Diagramm
  # CRITICAL: Führt beide Analyzer aus und fusioniert die Ergebnisse
  hybrid_fusion:
    use_swarm_analysis: true  # Swarm aktiviert
    use_monolith_analysis: true  # Monolith aktiviert
    use_fusion: true  # Fusion aktiviert (kombiniert Swarm + Monolith)
    use_self_correction_loop: true  # Self-Correction für Qualität
    use_normalization_engine: true  # Normalization für logische Korrekturen
    monolith_whole_image: false  # Monolith verwendet Quadranten für große Bilder
    swarm_model: "Google Gemini 2.5 Flash"
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Always Pro for Monolith
    detail_model: "Google Gemini 2.5 Flash"
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # STRATEGY 5: DEFAULT FLASH - Schnellste Strategie (nur Swarm, keine Fusion)
  # Optimiert für: Schnelle Analysen, kosteneffizient
  # Geschwindigkeit: ~3-8 Minuten pro Diagramm
  # CRITICAL: Echte Flash-Strategie = Nur Swarm, kein Monolith, keine Fusion
  # Verwendung: A/B-Tests, schnelle Iterationen, kosteneffiziente Analysen
  hybrid_fusion:
    use_swarm_analysis: true  # Swarm aktiviert (schnell)
    use_monolith_analysis: false  # CRITICAL: Monolith AUS (Flash = schnell)
    use_fusion: false  # CRITICAL: Fusion AUS (kein Monolith zu fusionieren)
    use_self_correction_loop: false  # CRITICAL: Self-Correction AUS (Flash = schnell)
    use_normalization_engine: true  # WICHTIG: Normalization AN (logische Korrekturen)
    monolith_whole_image: false  # Nicht verwendet (use_monolith_analysis: false)
    swarm_model: "Google Gemini 2.5 Flash"  # Flash für Geschwindigkeit
    monolith_model: "Google Gemini 2.5 Flash"  # Nicht verwendet
    detail_model: "Google Gemini 2.5 Flash"
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1 - Basis der Pipeline!)
  
  # LEGACY: Vollständig Flash (deprecated - nicht empfohlen)
  # ⚠️ WARNUNG: Diese Strategie verwendet Flash für Meta/Legend (Phase 1)
  # Dies ist NICHT empfohlen, da die gesamte Pipeline auf Phase 1 basiert
  # Nur für schnelle Tests oder wenn Qualität weniger wichtig ist
  all_flash:
    swarm_model: "Google Gemini 2.5 Flash"
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Always Pro for Monolith
    detail_model: "Google Gemini 2.5 Flash"
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"
    meta_model: "Google Gemini 2.5 Flash"  # ⚠️ WARNUNG: Flash statt Pro (nicht empfohlen!)

logic_parameters:
  # Phase 0: Complexity Analysis (REACTIVATED - CV-based fast analysis)
  use_phase0: true  # Enable CV-based complexity analysis for automatic strategy selection
  # use_phase0_llm: false  # LLM not used - CV-only multi-metric analysis
  
  # CRITICAL FIX 3: Hybrid Validation (CV + Semantic)
  # Combines CV line detection with semantic validation for better connection accuracy
  use_hybrid_validation: true  # Enable hybrid CV + semantic validation
  
  # ----------------------------------------------------
  # Phase 2: Analysis Strategy
  # ----------------------------------------------------
  # CRITICAL FIX 1.3: Swarm re-activated for simple_pid_strategy (to find SamplePoint-S & ISA-Supply)
  use_swarm_analysis: true  # Swarm as specialist for missing elements
  use_monolith_analysis: true  # Monolith as baseline (84% baseline)
  use_fusion: true  # Fusion with Monolith prioritization
  
  # ----------------------------------------------------
  # Globale Steuerung & Worker
  # ----------------------------------------------------
  # Maximale Anzahl der Korrektur-Iterationen in der Feedback-Schleife
  max_self_correction_iterations: 5
  # Score (0-100), bei dem die Korrekturschleife vorzeitig abbricht
  target_quality_score: 95.0  # Increased from 85.0 to 95.0 for "Top-Niveau" goal (ensures Phase 3 actually corrects errors)
  # Maximale Anzahl Iterationen ohne signifikante Verbesserung (Plateau-Erkennung)
  max_no_improvement_iterations: 3
  # Mindestverbesserung pro Iteration (in Punkten) um als "Verbesserung" zu zählen
  min_improvement_threshold: 0.5
  # Stoppe bei Plateau (keine Verbesserung mehr)
  early_stop_on_plateau: true
  
  # ----------------------------------------------------
  # Simple P&ID Mode: Optimiert für einfache P&IDs (≤15 Elemente)
  # ----------------------------------------------------
  simple_pid_mode: false  # Automatisch aktiviert wenn ≤15 Elemente erkannt
  # Wenn simple_pid_mode aktiv: max_iterations = 2, early_stop_threshold = 70-80%
  # CRITICAL FIX: Erzwinge mindestens 2 Durchläufe auch bei einfachen P&IDs
  simple_pid_max_iterations: 2  # Minimum 2 iterations for simple P&IDs
  simple_pid_early_stop_threshold: 85.0  # Increased from 70.0 to ensure at least 2 iterations run
  # Deaktiviere WHOLE-IMAGE re-analysis Fallback für einfache P&IDs
  simple_pid_disable_whole_image_fallback: true
  # Stop Phase 3 wenn < 5 uncertain zones (für einfache P&IDs)
  simple_pid_min_uncertain_zones: 5
  
  # PHASE 5.4: Maximale Anzahl paralleler Worker für die Analyse-Aufrufe (max 8-10 für API-Limits)
  # Increased from 4 to 6 for faster processing (Uni-Bilder optimization)
  llm_executor_workers: 4  # Reduziert von 6 auf 4 für bessere Stabilität bei komplexen P&IDs
  
  # ----------------------------------------------------
  # Phase 1: BBox Validierung & Verfeinerung
  # ----------------------------------------------------
  # Anzahl Erkennungsversuche für Legende/Metadata BBox
  bbox_validation_attempts: 3
  # Maximaler ausgeschlossener Bereich (als Anteil der Bildfläche, 0.0-1.0)
  max_excluded_area_percentage: 0.5
  # BBox-Verfeinerung aktivieren (Verkleinern wenn zu groß)
  bbox_refinement_enabled: true
  # Iterative Legend BBox-Verfeinerung (2-3 Iterationen bis optimal)
  use_legend_bbox_refinement: true  # Aktiviert iterative BBox-Verfeinerung mit visueller LLM-Rückmeldung
  # Visuelles Feedback für Self-Correction Loop (KI sieht ihre eigenen Ergebnisse)
  use_visual_feedback: true  # Aktiviert visuelles Feedback: Debug-Map wird generiert und an MultiModelCritic gesendet

  # ----------------------------------------------------
  # LLM Handler / Caching / Timeouts
  # ----------------------------------------------------
  # Standard-Timeout für einen LLM-Aufruf in Sekunden (höher für starke Modelle wie Pro)
  llm_default_timeout: 300  # Erhöht von 240 auf 300 Sekunden (5 Minuten) für komplexe P&IDs
  # Maximale Anzahl an Wiederholungsversuchen bei einem API-Fehler
  llm_max_retries: 3
  # Größe des Festplatten-Caches für LLM-Antworten in Gigabyte
  llm_disk_cache_size_gb: 2
  # Anzahl der Einträge im Memory-Cache (Level 1, LRU)
  llm_memory_cache_size: 100
  
  # ----------------------------------------------------
  # Circuit Breaker Configuration
  # ----------------------------------------------------
  # Anzahl Fehler, bevor der Circuit Breaker öffnet (erhöht für komplexe Analysen mit vielen Tiles)
  circuit_breaker_failure_threshold: 40   # Erhöht von 20 auf 40 für komplexe P&IDs (76+ API-Aufrufe: 70 Tiles + 6 Quadranten)
  # Wartezeit in Sekunden, bevor der Circuit Breaker versucht, sich zu erholen
  circuit_breaker_recovery_timeout: 180   # Erhöht von 120 auf 180 Sekunden (3 Minuten)
  
  # ----------------------------------------------------
  # LLM Logging Configuration
  # ----------------------------------------------------
  # Erweiterte Logging-Funktionalität für LLM-Calls
  llm_logging_enabled: true          # Enable detailed LLM logging
  llm_log_level: "DEBUG"              # Log level for LLM calls (DEBUG, INFO, WARNING, ERROR)
  llm_log_full_responses: true       # Log full responses (not just previews)
  llm_log_save_prompts: true          # Save full prompts to separate files
  llm_log_save_responses: true        # Save full responses to separate files
  llm_log_max_response_length: 10000  # Max length to log in main log (full saved to file)

  # ----------------------------------------------------
  # Phase 2: Schwarm & Monolith Analyse
  # ----------------------------------------------------
  # Aktivierung der einzelnen Analyse-Phasen
  use_swarm_analysis: true          # Swarm-Analyse aktivieren/deaktivieren
  use_monolith_analysis: true       # Monolith-Analyse aktivieren/deaktivieren
  use_fusion: true                  # Fusion von Swarm + Monolith aktivieren/deaktivieren
  # Ziel-Anzahl der Kacheln für die adaptive Segmentierung des Schwarms
  adaptive_target_tile_count: 50
  # Harte Obergrenze für die Anzahl der zu analysierenden Kacheln
  max_total_tiles: 80
  # Batch-Größe für die parallele Verarbeitung der Kacheln (wie viele auf einmal in den ThreadPool)
  analysis_batch_size: 5
  
  # ----------------------------------------------------
  # Two-Pass Pipeline (Coarse → Refine)
  # ----------------------------------------------------
  # PHASE 5.1: Aktiviert Two-Pass Pipeline für große Bilder (>4000px)
  # Enable for Uni-Bilder (large complex diagrams)
  two_pass_enabled: true
  # Kachelgröße für Pass 1 (Coarse)
  coarse_tile_size: 1024
  # Overlap für Pass 1 (Coarse) als Verhältnis (0.33 = 33%)
  coarse_overlap: 0.33
  # Kachelgröße für Pass 2 (Refine)
  refine_tile_size: 512
  # Overlap für Pass 2 (Refine) als Verhältnis (0.5 = 50%)
  refine_overlap: 0.5
  # Maximale Anzahl Refine-Kacheln (Budget)
  max_refine_tiles: 80
  # Confidence-Schwelle für unsichere Zonen
  low_confidence_threshold: 0.7

  # ----------------------------------------------------
  # Line Extraction
  # ----------------------------------------------------
  # DEPRECATED: Skeleton-based line extraction removed - using CV contour detection instead
  # use_skeleton_line_extraction: false

  # ----------------------------------------------------
  # Critics
  # ----------------------------------------------------
  # Enable Topology Critic validation
  use_topology_critic: true
  # Enable Legend Consistency Critic validation
  use_legend_consistency_critic: true

  # ----------------------------------------------------
  # Phase 2: Fusion & Lückenschließung
  # ----------------------------------------------------
  # Schwellenwert für die Überlappung (IoU), um zwei Elemente als identisch zu betrachten
  iou_match_threshold: 0.3  # Erhöht von 0.1 auf 0.3 für sicherere Fusion (siehe FusionEngine)
  # Distanzschwelle (als Anteil der Bilddiagonale) für die prädiktive Lückenschließung
  # CRITICAL FIX 2.1: Erhöht von 0.05 auf 0.08 für bessere Lückenschließung
  graph_completion_distance_threshold: 0.08
  # Predictive Completion aktivieren/deaktivieren
  use_predictive_completion: false  # DEAKTIVIERT für ersten Testlauf (Kern-System: Phase 0, 1, 2a, 2b, 2c-Fusion, 4)

  # ----------------------------------------------------
  # Phase 2e: Line Extractor - Gap Bridging
  # ----------------------------------------------------
  # Gap Bridging Threshold (in pixels) für die Verbindung von Liniensegmenten
  # Dieser Wert ist der "Stellhebel" für die Gap-Bridging-Logik
  # - Niedrigere Werte (z.B. 20): Strengere Verbindung (weniger falsche Verbindungen)
  # - Höhere Werte (z.B. 50): Tolerantere Verbindung (mehr Verbindungen, aber möglicherweise falsche)
  # Wenn nicht gesetzt, wird ein adaptiver Wert basierend auf der Bildgröße verwendet
  gap_bridging_threshold_px: 20  # Reduziert von 50 auf 20 für strengere Verbindung

  # ----------------------------------------------------
  # Phase 2e: Polyline Refinement
  # ----------------------------------------------------
  # Polyline Refinement aktivieren/deaktivieren
  use_polyline_refinement: false    # DEAKTIVIERT für ersten Testlauf (Kern-System: Phase 0, 1, 2a, 2b, 2c-Fusion, 4)

  # ----------------------------------------------------
  # Phase 4: Post-Processing & Filterung
  # ----------------------------------------------------
  # Post-Processing aktivieren/deaktivieren
  use_post_processing: true         # Post-Processing (KPIs, CGM, artifacts) aktivieren/deaktivieren
  # Self-Correction Loop aktivieren/deaktivieren
  use_self_correction_loop: false   # DEAKTIVIERT für ersten Testlauf (Kern-System: Phase 0, 1, 2a, 2b, 2c-Fusion, 4)
  # Active Learning aktivieren/deaktivieren
  use_active_learning: false        # Active Learning aktivieren/deaktivieren (WICHTIG: Während Tests deaktivieren, um schlechte Korrekturen nicht zu lernen)
  # Type-Validierung aktivieren/deaktivieren
  use_type_validation: true         # Type-Validierung aktivieren/deaktivieren
  # Confidence-Filterung aktivieren/deaktivieren
  use_confidence_filtering: true   # Confidence-Filterung aktivieren/deaktivieren (Zwei-Stufen)
  # Confidence-Schwellenwert für Element- und Verbindungs-Filterung (0.0 - 1.0)
  # Höher = weniger Halluzinationen, aber mehr verpasste Elemente
  # VERBESSERT: Zwei-Stufen-Filterung (siehe pipeline_coordinator.py)
  # - confidence >= 0.5: Behalten (auch als "Unknown")
  # - confidence 0.3-0.5: Behalten mit Penalty
  # - confidence < 0.3: Nur entfernen bei sehr niedriger Confidence
  confidence_threshold: 0.5  # Gesenkt von 0.6 auf 0.5 für bessere Datenintegrität
  
  # CV/OCR-based enhancements
  use_cv_bbox_refinement: true      # Refine bounding boxes with CV anchor method (centers symbols)
  use_cv_text_detection: true       # Detect text regions in tiles for label hints
  use_legend_matching: true         # Match legend symbols with diagram symbols using visual similarity
  
  # LLM-based improvements (SOFORTIGE, MITTELFRISTIGE, LANGFRISTIGE)
  use_llm_id_correction: true       # LLM-basierte ID-Korrektur und Alias-Auflösung
  use_context_type_inference: true  # Context-Aware Type-Inferenz (P&ID Naming Conventions)
  use_cot_reasoning: true           # Chain-of-Thought Reasoning für Verbindungen
  use_error_explanation: true      # Error Explanation durch LLM (Meta-Kritiker)
  use_multi_step_topology: true     # Multi-Step Reasoning für Topologie-Validierung

  # ----------------------------------------------------
  # Phase 4: CGM-Erstellung & Plots
  # ----------------------------------------------------
  # Liste der Typen, die im (optionalen) abstrahierten Graphen als Hauptkomponenten gelten
  cgm_main_components:
    - Boiler
    - Pump
    - Heat Exchanger
    - Buffer Storage
    - Thermal Consumer
    - Line_Split
    - Line_Merge
    - Diagram_Inlet
    - Diagram_Outlet
  # Parameter für das Layout des finalen Graphen (höherer k-Wert = mehr Abstand)
  cgm_plot_layout_k: 0.8
  cgm_plot_layout_iterations: 75

  # ----------------------------------------------------
  # KPI / Interne Bewertung
  # ----------------------------------------------------
  kpi_subgraph_penalty: 25.0
  kpi_isolated_penalty: 15.0
  kpi_dangling_penalty: 5.0
  kpi_unidentified_type_penalty: 2.0

training_camp:
  duration_hours: 3
  # Optionale Pfade für Bilderverzeichnisse
  image_paths:
    simple: "Testbilder/Einfache P_I_Diagramme"
    complex: "Testbilder/Komplexe P_I_Diagramme"
    symbols: "pretraining_symbols" # Ordner für Symbolbilder im Vortraining

  # Steuerung des Symbol-Vortrainings
  perform_symbol_pretraining: False # Wenn True, wird das Symbol-Vortraining im ersten Zyklus durchgeführt
  
  # Maximale Anzahl von Trainingszyklen (zusätzlich zur Zeit)
  max_cycles: 0 # 0 bedeutet unbegrenzt (nur Zeitlimit)

  # NEU: Schwellenwerte für Phasenwechsel (Anzahl aufeinanderfolgender hoher Scores)
  threshold_simple_to_complex: 3
  threshold_complex_to_no_truth: 5

  # Parameter-Kombinationen für Hyperparameter-Optimierung
  parameter_combinations:
    - {} # Basis-Parameter, keine Überschreibung
    - min_quality_to_keep_bbox: 0.6
    - visual_symbol_similarity_threshold: 0.80
    - min_quality_to_keep_bbox: 0.4
      visual_symbol_similarity_threshold: 0.90
    # Füge hier weitere Kombinationen hinzu, die du testen möchtest
    - llm_max_retries: 5 # Aggressivere Wiederholungsversuche bei LLM-Fehlern
    - llm_default_timeout: 120 # Längeres Timeout für komplexe LLM-Aufgaben
    - bbox_min_pixel_dim: 15 # Mindestgröße für BBoxes erhöhen (weniger kleine Fehler)
    - bbox_aspect_ratio_range: [0.2, 5.0] # Strengere Aspektverhältnis-Regel
    - graph_completion_distance_threshold: 0.03 # Kleinere Distanz für automatische Verbindung
    - graph_completion_isolated_node_distance: 0.03 # Kleinere Distanz für "echt isoliert"
    - min_quality_to_keep_bbox: 0.7 # Höhere Anforderung an BBox-Qualität
    - visual_symbol_similarity_threshold: 0.85 # Strengere visuelle Ähnlichkeit
    - llm_timeout_executor_workers: 4 # Weniger parallele LLM-Worker, wenn Stabilitätsprobleme auftreten
    - analysis_batch_size: 2 # Kleinere Batch-Größe für LLM-Aufrufe
    - precise_bbox_morph_kernel_size: 5 # Größerer Kernel für präzisere BBox-Extraktion
    - precise_bbox_min_component_area: 50 # Größerer Mindestbereich für Konturen
    - kpi_subgraph_penalty: 50.0 # Höhere Strafe für zerstückelte Graphen
    - kpi_isolated_penalty: 30.0 # Höhere Strafe für isolierte Elemente

  # Strategien und Modelle, die im Trainingslager getestet werden
  strategies_and_models_to_test:
  # Strategie 0: Simple Whole Image - Beste Strategie für einfache P&IDs
  simple_whole_image:
    meta_model: "Google Gemini 2.5 Pro"  # CRITICAL: Pro für Legend/Metadata (Phase 1)
    monolith_model: "Google Gemini 2.5 Pro"  # CRITICAL: Starkes Modell für ganzes Bild
    detail_model: "Google Gemini 2.5 Pro"  # Pro für bessere Präzision
    polyline_model: "Google Gemini 2.5 Flash"  # Flash ausreichend (CV-basiert)
    correction_model: "Google Gemini 2.5 Pro"  # Pro für besseres Reasoning
    critic_model_name: "Google Gemini 2.5 Pro"  # Pro für bessere Kritik
    use_swarm_analysis: false  # CRITICAL: Swarm deaktiviert (Tiles sind bei einfachen Bildern schlechter)
    use_monolith_analysis: true  # Monolith aktiviert
    use_fusion: false  # Keine Fusion nötig (nur Monolith)
    use_self_correction_loop: true  # Self-Correction für Qualität
    use_normalization_engine: true  # Wichtig, um "S" -> "pipe" zu fangen
    monolith_whole_image: true  # CRITICAL: Analysiere ganzes Bild, keine Quadranten
  
  # Strategie 1: Der schnelle Allrounder
  hybrid_fusion:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Flash"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Flash"
    code_gen_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"

  # Strategie 2: Maximale Qualität, egal was es kostet
  high_accuracy:
    meta_model: "Google Gemini 2.5 Pro"
    hotspot_model: "Google Gemini 2.5 Pro" # Angepasst zu Pro für volle High-Accuracy
    detail_model: "Google Gemini 2.5 Pro"
    coarse_model: "Google Gemini 2.5 Pro"
    correction_model: "Google Gemini 2.5 Pro"
    code_gen_model: "Google Gemini 2.5 Pro"
    critic_model_name: "Google Gemini 2.5 Pro"

  # Strategie 3: Der Chirurg - Pro-Modell nur für das Wesentliche
  balanced_pro_detail:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Pro"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Pro"
    code_gen_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"

  # Strategie 4: Der visuelle Spezialist - Flash für alles Visuelle
  flash_vision_pro_logic:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Flash"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Pro"
    code_gen_model: "Google Gemini 2.5 Pro"
    critic_model_name: "Google Gemini 2.5 Pro"

  # Strategie 5: Nutzt nur ältere/günstigere Flash-Modelle (1.5)
  low_cost_all_flash:
    meta_model: "Google Gemini 1.5 Flash"
    hotspot_model: "Google Gemini 1.5 Flash"
    detail_model: "Google Gemini 1.5 Flash"
    coarse_model: "Google Gemini 1.5 Flash"
    correction_model: "Google Gemini 1.5 Flash"
    code_gen_model: "Google Gemini 1.5 Flash"
    critic_model_name: "Google Gemini 1.5 Flash"

  # Strategie 6: Mischung aus 2.5 Flash für Geschwindigkeit und 2.5 Pro für Genauigkeit (Logik)
  mixed_speed_accuracy:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Flash"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Pro"
    code_gen_model: "Google Gemini 2.5 Pro"
    critic_model_name: "Google Gemini 2.5 Pro"

  # Strategie 7: Pro für die Kern-Detektion, Rest Flash
  pro_detection_flash_rest:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Pro"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Flash"
    code_gen_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"

  # Strategie 8: Nur das 2.5 Flash-Modell für alles
  minimalist_flash:
    meta_model: "Google Gemini 2.5 Flash"
    hotspot_model: "Google Gemini 2.5 Flash"
    detail_model: "Google Gemini 2.5 Flash"
    coarse_model: "Google Gemini 2.5 Flash"
    correction_model: "Google Gemini 2.5 Flash"
    code_gen_model: "Google Gemini 2.5 Flash"
    critic_model_name: "Google Gemini 2.5 Flash"

prompts:
  general_system_prompt: "You are a high-precision, deterministic JSON-outputting analysis engine."

  metadata_extraction_user_prompt: |
    **TASK:** Extract P&ID METADATA from the TITLE BLOCK, which is enclosed by a black rectangle.
    **OUTPUT:** A single, valid JSON object.
    **STRATEGY:**
    1.  **Locate Box:** Find the distinct black rectangle enclosing the title block. Its coordinates are `"metadata_bbox"`. Be extremely precise.
    2.  **Extract Text Inside:** Analyze ONLY the content inside this box for `"project"`, `"title"`, `"version"`, and `"date"`.
    **RULES:**
    - If a value is not found, use an empty string ("").
    - Provide ONLY the JSON object. NO additional text.
    **EXAMPLE:**
    ```json
    {
      "project": "ETA im Bestand", "title": "HNHT (Heating Network High Temperature)", "version": "1.0", "date": "17.05.2024",
      "metadata_bbox": {"x": 0.8, "y": 0.9, "width": 0.15, "height": 0.08}
    }
    ```

  legend_extraction_user_prompt: |
    **TASK:** You will receive a CROPPED image showing ONLY the P&ID Legend.
    Analyze it and extract ALL symbol and line definitions.
    **OUTPUT:** A single, valid JSON object with "symbol_map" and "line_map".
    
    **STRATEGIE (WIE EIN MENSCH):**
    1.  **Symbol Map:** Scanne die Legende. Finde ein Symbol-Bild (die Grafik) und lies den Text daneben (z.B. "Pumpe", "Ventil", "V-01").
        - Erstelle ein Mapping: `symbol_map: { "Gelesener Text": "Standard-Typ" }`
        - Beispiel: Wenn du "Pumpe P-01" liest, erstelle: `"Pumpe P-01": "Pump"`
        - Beispiel: Wenn du "Dreiwegeventil" liest, erstelle: `"Dreiwegeventil": "Valve"`
    2.  **Line Map:** Scanne nach Linien-Definitionen (z.B. "Rote Linie", "Gestrichelt").
        - Erfasse die **semantische Bedeutung** (z.B. "Heißwasser", "Luft") UND die **visuellen Eigenschaften** (Farbe, Stil).
    
    **RULES:**
    - Provide ONLY the JSON object. NO additional text.
    - Use standard P&ID types ("Pump", "Valve", "Tank", "Source", "Sink", "Mixer", "Heat Exchanger", "Volume Flow Sensor").
    - Für Linien, nutze Stile: "solid", "dashed", "dotted".
    
    **EXAMPLE OUTPUT (Folge diesem Format exakt):**
    ```json
    {
      "symbol_map": {
        "Pumpe P-01": "Pump",
        "P-02": "Pump",
        "Ventil V-01": "Valve",
        "Mischer M-01": "Mixer"
      },
      "line_map": {
        "Heißwasser (VL)": {
          "semantic_meaning": "Heißwasser Vorlauf",
          "visual_properties": {
            "color": "red",
            "style": "solid"
          }
        },
        "Kaltwasser (RL)": {
          "semantic_meaning": "Kaltwasser Rücklauf",
          "visual_properties": {
            "color": "blue",
            "style": "solid"
          }
        },
        "Luftabgänge": {
          "semantic_meaning": "Luft",
          "visual_properties": {
            "color": "black",
            "style": "dashed"
          }
        }
      }
    }
    ```
  
  legend_text_to_structure_prompt: |
    You are a P&ID legend parser. Extract symbol types and line styles from the following legend text.
    
    The text is from a P&ID diagram legend (extracted via OCR). Extract:
    1. Symbol mappings (symbol_key -> symbol_type)
    2. Line mappings (line_key -> {color, style})
    
    **CRITICAL:**
    - Use EXACT type names from ISO/DIN standards (e.g., "Valve", "Pump", "Volume Flow Sensor")
    - DO NOT invent new types - use standard P&ID types
    - If uncertain, use the most common standard type
    
    **OUTPUT FORMAT:**
    Return a valid JSON object with:
    - symbol_map: {symbol_key: symbol_type}
    - line_map: {line_key: {color: "color_name", style: "solid|dashed|dotted"}}
    
    **EXAMPLE:**
    Input text: "Valve - V | Pump - P | Flow Meter - FT"
    Output:
    {
      "symbol_map": {
        "V": "Valve",
        "P": "Pump",
        "FT": "Volume Flow Sensor"
      },
      "line_map": {}
    }
    
    Legend text:
    {raw_text}
    
    Return ONLY valid JSON, no additional text.
    **EXAMPLE:**
    ```json
    {
      "symbol_map": { "Pump": "Pump", "Flow": "Flow Meter" },
      "line_map": { "Return": { "color": "blue", "style": "solid" } },
      "legend_bbox": {"x": 0.01, "y": 0.02, "width": 0.15, "height": 0.25}
    }
    ```

  swarm_analysis_user_prompt_template: |-
    **ROLE:** You are a P&ID analysis engine with high precision requirements.
    **TASK:** Analyze the provided image segment and identify ALL components (symbols and text labels).
    
    **CRITICAL:** Your ONLY task is to find ELEMENTS. IGNORE all connections (lines/pipes).
    
    **CRITICAL: STRICT TYPE CONSTRAINTS (STRICTLY ENFORCE):**
    1. You MUST use EXACT types from this list: {known_types_json}
    2. Type names are CASE-SENSITIVE: "Valve" NOT "valve", "Pump" NOT "pump"
    3. If you see a valve symbol, use "Valve" (capitalized, exact spelling)
    4. If you see a pump symbol, use "Pump" (capitalized, exact spelling)
    5. If you see a flow sensor, use "Volume Flow Sensor" (exact phrase, case-sensitive)
    6. If you see a mixer, use "Mixer" (capitalized, exact spelling)
    7. If you see a source, use "Source" (capitalized, exact spelling)
    8. If you see a sink, use "Sink" (capitalized, exact spelling)
    9. If you see a sample point, use "Sample Point" (exact phrase, case-sensitive)
    10. DO NOT invent new types - ONLY use types from the list
    11. DO NOT use lowercase or variations - use EXACT type names
    12. DO NOT use synonyms - use EXACT type names from the list
    
    **CRITICAL ANTI-HALLUCINATION RULES (STRICTLY ENFORCE):**
    - ONLY identify elements that are CLEARLY VISIBLE and have STRONG visual evidence in the image
    - If you are uncertain about an element (even slightly), DO NOT include it - ERR on the side of caution
    - DO NOT invent elements that are not in the image - this is a critical error
    - DO NOT guess element types or labels - if unclear, exclude the element
    - When in doubt, leave it out - PRECISION IS MORE IMPORTANT THAN RECALL
    - Verify each element has BOTH: clear visual symbol pattern AND readable label/text
    - Only include elements where you are >30% confident - when uncertain, exclude
    - DO NOT include elements based on expected patterns - only actual visual evidence counts
    
    **FEW-SHOT EXAMPLES (FOLLOW EXACTLY - THESE ARE CRITICAL FOR CORRECT TYPE RECOGNITION):**
    
    Example 1: Valve (MOST COMMON)
    - Visual: Circle with diagonal line through it, or control valve symbol (circle with line and arrow)
    - Label: "Fv-3-3040" or "Fv-3-3041" or "V-101" or "CV-42"
    - Type: "Valve" (EXACT spelling, capitalized)
    - WRONG: "valve", "control valve", "Control Valve", "Valves", "valves", "ControlValve", "control_valve"
    - CORRECT: "Valve" (only this exact string)
    {viewshot_valve_examples}
    
    Example 2: Flow Sensor (COMMON)
    - Visual: Diamond shape with text inside, or flow meter symbol (diamond with arrow)
    - Label: "FT-10" or "FT-11" or "F-201" or "FM-05"
    - Type: "Volume Flow Sensor" (EXACT phrase, case-sensitive, with space)
    - WRONG: "Sensor", "flow meter", "Flow Meter", "Flow Sensor", "sensor", "FlowSensor", "volume_flow_sensor"
    - CORRECT: "Volume Flow Sensor" (exact phrase with space, capitalized)
    {viewshot_flow_sensor_examples}
    
    Example 3: Mixer (COMMON)
    - Visual: Mixing symbol (circle with multiple lines or blending symbol)
    - Label: "M-08" or "MX-101" or "Mixer-5"
    - Type: "Mixer" (EXACT spelling, capitalized)
    - WRONG: "machine", "mixer", "Machine", "Blender", "blender", "MixingMachine", "mixing_machine"
    - CORRECT: "Mixer" (only this exact string)
    {viewshot_mixer_examples}
    
    Example 4: Source (COMMON)
    - Visual: Source symbol (circle with arrow pointing out) or pump symbol with label starting with "P-"
    - Label: "P-201" or "P-504" or "S-101" or "Source-1"
    - Type: "Source" (EXACT spelling, capitalized)
    - WRONG: "source", "pump", "Pump", "Inlet", "inlet", "SourcePump", "source_pump"
    - CORRECT: "Source" (only this exact string)
    {viewshot_source_examples}
    
    Example 5: Sample Point (COMMON)
    - Visual: Sample point symbol (small circle with line or dot)
    - Label: "S" or "SamplePoint-S" or "SP-101" or "Sample-1"
    - Type: "Sample Point" (EXACT phrase, case-sensitive, with space)
    - WRONG: "sample point", "SamplePoint", "Sampling Point", "sample_point", "Sample", "sample"
    - CORRECT: "Sample Point" (exact phrase with space, capitalized)
    {viewshot_sample_point_examples}
    
    Example 6: Pump (COMMON)
    - Visual: Pump symbol (circle with arrow or pump icon)
    - Label: "P-101" or "Pump-1" or "PUMP-201"
    - Type: "Pump" (EXACT spelling, capitalized)
    - WRONG: "pump", "PUMPS", "pumps", "PumpMachine", "pump_machine"
    - CORRECT: "Pump" (only this exact string)
    {viewshot_pump_examples}
    
    Example 7: Sink (COMMON)
    - Visual: Sink symbol (circle with arrow pointing in or drain symbol)
    - Label: "Sink-1" or "D-101" or "Drain-5"
    - Type: "Sink" (EXACT spelling, capitalized)
    - WRONG: "sink", "SINKS", "sinks", "Drain", "drain", "SinkDrain", "sink_drain"
    - CORRECT: "Sink" (only this exact string)
    {viewshot_sink_examples}
    
    **VIEWSHOT EXAMPLES (VISUAL REFERENCE FROM REAL UNI-BILDER):**
    {viewshot_section}
    
    **CRITICAL REMINDERS:**
    - Type names are CASE-SENSITIVE: "Valve" != "valve"
    - Type names with spaces must have EXACT spacing: "Sample Point" != "SamplePoint" != "Sample Point"
    - DO NOT use lowercase, synonyms, or variations - ONLY use exact type names from the list
    - When in doubt, check the exact type name from the list above
    
    **CRITICAL: ID vs. LABEL RULES (STRICTLY ENFORCE):**
    1. **"id" FIELD:** MUST be the P&ID Tag Name ONLY. It must be short, alphanumeric, and contain hyphens (e.g., 'P-201', 'Fv-3-3040', 'M-08', 'ISA').
    2. **"label" FIELD:** MUST be the FULL descriptive text found near the symbol (e.g., 'From Transfer Pump P-201', 'Mixer M-08', '(Instrument Air Supply)').
    3. If Tag Name and Label are identical (e.g., only "M-08" is visible), use it for BOTH fields.
    
    **EXAMPLE 1 (Long Label):**
    - Visual Text: "From Transfer Pump P-201"
    - Output `id`: "P-201"
    - Output `label`: "From Transfer Pump P-201"
    
    **EXAMPLE 2 (Short Label):**
    - Visual Text: "M-08"
    - Output `id`: "M-08"
    - Output `label`: "M-08"
    
    **CRITICAL: BOUNDING BOX (BBox) RULES (STRICTLY ENFORCE):**
    - The "bbox" MUST be a TIGHT box around the GRAPHICAL SYMBOL ONLY.
    - The "bbox" MUST NOT include the 'id' or 'label' text sitting next to it.
    - Make the "bbox" as small as possible while still enclosing the entire symbol.
    
    **OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object with "elements" and "connections" keys.
    
    **CRITICAL: CONFIDENCE SCORES (MANDATORY):**
    - EVERY element MUST have a "confidence" field (float, 0.0-1.0)
    - EVERY connection MUST have a "confidence" field (float, 0.0-1.0)
    - Confidence represents your certainty: 1.0 = absolutely certain, 0.0 = completely uncertain
    - Be honest: If you're unsure, use lower confidence (e.g., 0.6-0.7)
    - If you're very certain, use higher confidence (e.g., 0.9-1.0)
    - DO NOT omit confidence scores - they are MANDATORY for every element and connection
    
    **1. "elements" List:**
    - Find ONLY components that are CLEARLY VISIBLE with strong visual evidence
    - REQUIRED KEYS: `"id"` (P&ID Tag Name, e.g., "P-201"), `"type"` (EXACT type from list), `"label"` (full descriptive text), and a tight `"bbox"` (symbol only, no text).
    - **`"confidence"`**: (float, 0.0-1.0) Your confidence that this element is correct (0.9+ = Very Sure, < 0.5 = Guessing).
    - **`"ports"`**: (MANDATORY) List of ports for this element. Each port must have: `"id"` (e.g., "in_1", "out_1", "control_1"), `"name"` (e.g., "In", "Out", "Control"), `"type"` ("input", "output", or "control").
      - **Input ports**: For elements that receive flow FROM other elements (most elements have at least 1 input)
      - **Output ports**: For elements that send flow TO other elements (most elements have at least 1 output)
      - **Control ports**: For Valves that receive control signals (e.g., from ISA/Instrument Air Supply)
      - **CRITICAL**: If you cannot determine ports visually, provide default ports: `[{"id": "in_1", "name": "In", "type": "input"}, {"id": "out_1", "name": "Out", "type": "output"}]`
      - **CRITICAL**: Valves MUST have a control port if control lines are visible: `{"id": "control_1", "name": "Control", "type": "control"}`
    - Use EXACT type names from the list above - CASE-SENSITIVE
    - Only include 'Line_Split' and 'Line_Merge' if they are CLEARLY VISIBLE and have visual evidence
    - If an element's label or type is ambiguous, DO NOT include it

    **2. "connections" List:**
    - CRITICAL: Provide an EMPTY list. You MUST NOT detect connections.
    - ` "connections": [] `
    - **NOTE:** If you are instructed to detect connections, REQUIRED KEYS are `"from_id"`, `"to_id"`, `"from_port_id"`, `"to_port_id"`.
    - **`"confidence"`**: (float, 0.0-1.0) Your confidence that this connection is correct (0.9+ = Very Sure, < 0.5 = Guessing).

    **KNOWLEDGE BASE (Use these EXACT types - CASE-SENSITIVE):**
    {known_types_json}

    {legend_context}

    **CORRECTION FEEDBACK (Fix these errors from the last run):**
    {error_feedback}
    
    **EXAMPLE STRUCTURE (FOLLOW EXACTLY - NOTE EXACT TYPE NAMES, PORTS, AND CONFIDENCE):**
    ```json
    {
      "elements": [
        {
          "id": "P-101", "label": "Main Pump P-101", "type": "Pump",
          "bbox": {"x": 0.1, "y": 0.2, "width": 0.05, "height": 0.04},
          "ports": [
            {"id": "out_1", "name": "Out", "type": "output"}
          ],
          "confidence": 0.95
        },
        {
          "id": "Fv-3-3040", "label": "Control Valve Fv-3-3040", "type": "Valve",
          "bbox": {"x": 0.3, "y": 0.4, "width": 0.02, "height": 0.03},
          "ports": [
            {"id": "in_1", "name": "In", "type": "input"},
            {"id": "out_1", "name": "Out", "type": "output"},
            {"id": "control_1", "name": "Control", "type": "control"}
          ],
          "confidence": 0.90
        }
      ],
      "connections": []
    }
    ```
    
    **CRITICAL:** Every element MUST include "confidence" (0.0-1.0). This is MANDATORY.
    
  monolithic_analysis_prompt_template: |-
    **ROLE:** You are a P&ID Topology Specialist.
    **TASK:** Your ONLY task is to find ALL connections (lines/pipes) between the elements provided in the knowledge base.
    
    **CRITICAL KNOWLEDGE BASE (INPUT):**
    Here is a complete JSON list of all known elements on the diagram. You MUST use their exact IDs.
    `{element_list_json}`
    
    **CRITICAL RULES (STRICTLY ENFORCE):**
    1. **ONLY DETECT CONNECTIONS.** Do NOT detect elements.
    2. Use the EXACT element IDs from the knowledge base for `"from_id"` and `"to_id"`.
    3. Find ALL visible lines/pipes connecting these elements within the image.
    4. DO NOT invent connections that are not visually present.
    5. IGNORE connections to elements NOT in the provided list.
    
    {legend_context}
    {error_feedback}
    
    **OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object.
    
    **1. "elements" List:**
    - CRITICAL: Provide an EMPTY list. You MUST NOT detect elements.
    - ` "elements": [] `
    - **NOTE:** If the prompt is modified to allow additional element detection (e.g., in simple P&ID mode or when legend symbols are missing), then:
      - REQUIRED KEYS: `"id"`, `"type"`, `"label"`, `"bbox"`, `"confidence"`.
      - **`"confidence"`:** (float, 0.0-1.0) Your certainty that this element is correctly identified. 0.9+ = Very certain, < 0.5 = Guessed.
      - **`"ports"`**: (MANDATORY) List of ports for this element. Each port must have: `"id"` (e.g., "in_1", "out_1", "control_1"), `"name"` (e.g., "In", "Out", "Control"), `"type"` ("input", "output", or "control").
        - **Input ports**: For elements that receive flow FROM other elements (most elements have at least 1 input)
        - **Output ports**: For elements that send flow TO other elements (most elements have at least 1 output)
        - **Control ports**: For Valves that receive control signals (e.g., from ISA/Instrument Air Supply)
        - **CRITICAL**: If you cannot determine ports visually, provide default ports: `[{"id": "in_1", "name": "In", "type": "input"}, {"id": "out_1", "name": "Out", "type": "output"}]`
        - **CRITICAL**: Valves MUST have a control port if control lines are visible: `{"id": "control_1", "name": "Control", "type": "control"}`
    
    **2. "connections" List:**
    - Find ALL connections (lines/pipes) between the elements in the knowledge base.
    - REQUIRED KEYS: `"from_id"`, `"to_id"`, `"from_port_id"`, `"to_port_id"`, `"kind"`.
    - **`"from_port_id"`**: ID of the output port on the source element (e.g., "out_1")
    - **`"to_port_id"`**: ID of the input port on the destination element (e.g., "in_1")
    - **`"kind"`**: Type of connection - MUST be one of: "process" (for process lines/pipes), "control" (for control lines like ISA/Instrument Air Supply), "electrical" (for electrical connections). 
      - **CRITICAL**: Connections from ISA/Instrument Air Supply to Valves MUST have `"kind": "control"`
      - **CRITICAL**: Regular process flow connections (Pump → Valve → Sensor → Mixer) MUST have `"kind": "process"`
    - **`"confidence"`**: (float, 0.0-1.0) Your confidence that this connection is correct (0.9+ = Very Sure, < 0.5 = Guessing).
    - **CRITICAL CONNECTION RULES:**
      - Sensors (FT-*, PT-*, etc.) should NOT be sources (from_id) - they measure flow, they don't generate it
      - Sources (Pumps, P-*, etc.) should only have outputs (to_id) - they generate flow
      - Control lines (ISA) should ONLY connect to Valves (not to Pumps, Sensors, or Mixers)
      - If you see a connection like "FT-10 → Fv-3-3040", it's WRONG - reverse it to "Fv-3-3040 → FT-10"
    
    **CRITICAL: CONFIDENCE SCORES (MANDATORY):**
    - EVERY connection MUST have a "confidence" field (float, 0.0-1.0)
    - EVERY element (if detected) MUST have a "confidence" field (float, 0.0-1.0)
    - Confidence represents your certainty: 1.0 = absolutely certain, 0.0 = completely uncertain
    - Be honest: If the element/connection is clear and visible, use high confidence (0.9-1.0)
    - If the element/connection is partially obscured or unclear, use lower confidence (0.6-0.8)
    - DO NOT omit confidence scores - they are MANDATORY for every element and connection
    
    **EXAMPLE STRUCTURE (FOLLOW EXACTLY):**
    ```json
    {
      "elements": [],
      "connections": [
        {
          "from_id": "P-101",
          "to_id": "Fv-3-3040",
          "from_port_id": "out_1",
          "to_port_id": "in_1",
          "kind": "process",
          "confidence": 0.95
        },
        {
          "from_id": "Fv-3-3040",
          "to_id": "M-08",
          "from_port_id": "out_1",
          "to_port_id": "in_1",
          "kind": "process",
          "confidence": 0.90
        },
        {
          "from_id": "ISA",
          "to_id": "Fv-3-3040",
          "from_port_id": "out_1",
          "to_port_id": "control_1",
          "kind": "control",
          "confidence": 0.95
        }
      ]
    }
    ```
    
    **NOTE:** If elements are detected (e.g., in simple P&ID mode), the structure would be:
    ```json
    {
      "elements": [
        {
          "id": "P-101",
          "type": "Pump",
          "label": "Main Pump P-101",
          "bbox": {"x": 0.1, "y": 0.2, "width": 0.05, "height": 0.04},
          "ports": [
            {"id": "out_1", "name": "Out", "type": "output"}
          ],
          "confidence": 0.95
        }
      ],
      "connections": [
        {
          "from_id": "P-101",
          "to_id": "Fv-3-3040",
          "from_port_id": "out_1",
          "to_port_id": "in_1",
          "kind": "process",
          "confidence": 0.90
        }
      ]
    }
    ```
    
    **CRITICAL:** Every connection MUST include "confidence" (0.0-1.0). Every element (if detected) MUST include "confidence" (0.0-1.0). This is MANDATORY.

  polyline_extraction_user_prompt: |
    **ROLE:** You are a vectorization engine.
    **TASK:** Analyze the provided pre-processed image, which ONLY shows pipelines. Trace the exact centerline of every visible line segment.
    **OUTPUT:** A single JSON object with ONE key: "polylines", containing a list of objects.
    **RULES:**
    - Each object MUST contain `"polyline"`, a list of `[x, y]` coordinate pairs (floats 0-1).
    - Provide ONLY the JSON object.

  swarm_specialist_prompt_template: |
    **ROLE:** You are a highly specialized P&ID analysis agent.
    **TASK:** Analyze the provided image segment and identify ONLY the following specific components:
    - "Sample Point" (e.g., labeled "S", "Sample Point", or a simple circle symbol)
    - "Source" (e.g., labeled "ISA", "Air Supply", "Instrument Air Supply")

    **CRITICAL: STRICT TYPE CONSTRAINTS (STRICTLY ENFORCE):**
    1. You MUST use EXACT types from this list: ['SamplePoint', 'Source']
    2. You MUST only identify elements that clearly match these types.
    3. If an element does not clearly match 'SamplePoint' or 'Source', DO NOT include it.

    **OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object with "elements" and "connections" keys.
    (Connections are not expected for this specialist task, but the structure must be present).

    **1. "elements" List:**
    - Find ONLY components that are CLEARLY VISIBLE with strong visual evidence and match 'SamplePoint' or 'Source'.
    - REQUIRED KEYS: `"id"` (the text label, e.g., "S", "ISA-Supply"), `"type"` (EXACT type from list), `"label"`, and a tight `"bbox"`.
    - Assign a high confidence (e.g., 0.9) if you are certain.

    **2. "connections" List:**
    - This specialist is not focused on connections. Provide an empty list.

    **EXAMPLE STRUCTURE (FOLLOW EXACTLY):**
    ```json
    {
      "elements": [
        {
          "id": "S", "label": "Sample Point S", "type": "SamplePoint",
          "bbox": {"x": 0.1, "y": 0.2, "width": 0.02, "height": 0.02}, "confidence": 0.9
        },
        {
          "id": "ISA-Supply", "label": "Instrument Air Supply", "type": "Source",
          "bbox": {"x": 0.8, "y": 0.1, "width": 0.05, "height": 0.03}, "confidence": 0.9
        }
      ],
      "connections": []
    }
    ```

  metacritic_prompt_template: |
    **ROLE:** You are a meticulous P&ID Quality Assurance Engineer and a Metacritic expert with expertise in validating technical diagram analyses.
    **TASK:** You will be provided with two analysis results for the same P&ID image:
    1.  The "Monolithic Analysis" (a global, high-level understanding of the entire diagram).
    2.  The "Swarm Analysis" (a detailed, tile-based understanding with high precision).

    **YOUR MISSION:** Identify high-level, logical, or systemic discrepancies between these two results. Focus ONLY on significant issues where one analysis sees something important that the other completely misses or fundamentally misinterprets, leading to logical contradictions or critical gaps in understanding.

    **CRITICAL DISCREPANCY CRITERIA (STRICTLY ENFORCE):**

    **1. Hallucinated_Elements**
    - **Definition:** An element present in one analysis that is COMPLETELY ABSENT and UNIDENTIFIABLE in the other analysis (not just a position mismatch).
    - **Evaluation Criteria (STRICTLY ENFORCE):**
      * **CRITICAL - IoU-Based Evaluation:** Calculate the Intersection over Union (IoU) between the BBox in Analysis 1 and the nearest BBox in Analysis 2. If IoU < 0.3, it is likely a hallucination. IoU >= 0.3 means the elements overlap significantly and are likely the same element (even if BBox size differs).
      * **Confidence Check:** If one analysis has confidence <0.5 AND the other has no element at all (IoU < 0.3), flag as potential hallucination.
      * **Element Type and Label Verification:** If element types match but labels differ significantly, calculate IoU first. Only if IoU < 0.3, then verify if it's truly a different element (not just a labeling difference).
      * **IGNORE - BBox Precision Differences:** A difference in BBox precision (smaller vs larger BBox) is NOT a hallucination - it's a refinement. Only flag if IoU < 0.3 AND element is completely absent.
      * **IoU Calculation:** IoU = (Intersection Area) / (Union Area) of two bounding boxes. IoU ranges from 0 (no overlap) to 1 (perfect overlap).
    - **Example (CORRECT):** "Monolithic analysis reports 'Pump P-101' at bbox(x:0.15, y:0.20, w:0.05, h:0.04) with confidence 0.9. Swarm analysis has nearest element at bbox(x:0.16, y:0.21, w:0.04, h:0.03). IoU = 0.25 (< 0.3 threshold). This suggests a hallucination by Monolithic analysis."
    - **Example (INCORRECT - Do NOT flag):** "Monolithic has bbox(x:0.15, y:0.20, w:0.05, h:0.04), Swarm has bbox(x:0.16, y:0.21, w:0.04, h:0.03). IoU = 0.45 (>= 0.3). These are the SAME element with different BBox precision. NOT a hallucination."

    **2. Missed_Connections**
    - **Definition:** A connection identified in one analysis that is COMPLETELY MISSING in the other analysis, where BOTH source and target elements exist in both analyses.
    - **Evaluation Criteria:**
      * Verify that both 'from_id' and 'to_id' elements exist in BOTH analyses
      * Check if the connection is critical (connects major components, not just line segments)
      * Ignore minor connection differences (e.g., Line_Split vs Line_Merge variations)
    - **Example:** "Swarm analysis shows connection from 'Pump P-001' to 'Valve V-002', both elements exist in Monolithic analysis with matching IDs, but Monolithic analysis has NO connection between them. This is a missed connection."

    **3. Global_Inconsistency**
    - **Definition:** Major structural or logical contradictions that don't fit the above categories but indicate fundamental differences in understanding.
    - **Evaluation Criteria:**
      * Component count discrepancies: >20% difference in total element count
      * Process flow contradictions: Major differences in connection patterns
      * Confidence score anomalies: Systematic differences in confidence distributions
      * BBox precision issues: Systematic differences in bounding box sizes (if many elements have significantly larger BBoxes in one analysis, it may indicate lower precision)
    - **Example:** "Monolithic analysis reports 8 pumps, Swarm analysis reports 3 pumps. This 62% discrepancy indicates a major inconsistency requiring reconciliation."

    **CONFIDENCE & BBOX PRECISION EVALUATION (CRITICAL):**
    - **ALWAYS calculate IoU first** before flagging any element as hallucinated
    - **IoU >= 0.3:** Elements are likely the SAME element (even if BBox size/position differs slightly). Do NOT flag as hallucination.
    - **IoU < 0.3:** Elements are likely DIFFERENT. Only then check if it's truly a hallucination (missing in one analysis).
    - **BBox refinement (smaller/larger area):** This is EXPECTED and GOOD, not a discrepancy. IoU will still be high (>= 0.3) if it's the same element.
    - **Confidence scores:** Elements with confidence <0.5 are less reliable, but still use IoU to verify if they're the same element.
    - **Only flag as hallucination if:** IoU < 0.3 AND element is completely absent in the other analysis (not just refined).

    **INPUT CONTEXT:**
    - Monolithic Analysis Data: {monolith_json}
    - Swarm Analysis Data: {swarm_json}

    **CRITICAL OUTPUT FORMAT (STRICTLY FOLLOW):**
    You MUST provide a valid JSON object with EXACTLY this structure. Each discrepancy must have all three fields.
    ```json
    {{
      "discrepancies": [
        {{
          "id": "Hallucinated_Element",
          "description": "PRECISE description with element ID, type, coordinates, IoU value (if applicable), and why it's a hallucination. MUST include IoU calculation if comparing with element in other analysis.",
          "suggested_correction_action": "Specific action to correct (e.g., 'Remove element P-101 from monolithic result' or 'Verify element HX-101 exists at coordinates (0.15, 0.20)')"
        }},
        {{
          "id": "Missed_Connection",
          "description": "PRECISE description with connection details (from_id, to_id) and why it's missed",
          "suggested_correction_action": "Specific action (e.g., 'Add connection from P-001 to V-002 to monolithic result')"
        }},
        {{
          "id": "Global_Inconsistency",
          "description": "PRECISE description of the inconsistency with quantitative details (counts, percentages)",
          "suggested_correction_action": "Specific reconciliation action"
        }}
      ]
    }}
    ```

    **OUTPUT RULES:**
    - Provide ONLY the JSON object, no additional text
    - If no discrepancies found, return: {{"discrepancies": []}}
    - Maximum 10 discrepancies per analysis (focus on most critical)
    - **Be precise:** Include element IDs, coordinates, confidence scores, AND IoU values where relevant
    - **For Hallucinated_Elements:** ALWAYS include IoU calculation in description (e.g., "IoU = 0.25 < 0.3 threshold, element absent in other analysis")
    - Be actionable: suggested_correction_action must be specific and executable

  # ----------------------------------------------------
  # Visual Feedback Critique Prompt (for MultiModelCritic)
  # ----------------------------------------------------
  visual_feedback_critique_prompt_template: |
    **TASK:** Du bist ein P&ID-Chef-Inspektor mit visueller Expertise. Du wirst zwei Bilder sehen:

    1. **[Originalbild]:** Das zu analysierende P&ID-Diagramm (wird im Prompt erwähnt, aber du siehst das Debug-Bild)
    2. **[Debug-Bild]:** Eine Visualisierung der aktuellen Analyse (was die untergeordnete KI erkannt hat) - DIESES BILD SIEHST DU

    **AKTUELLE ANALYSE (JSON):**
    - Elemente: {elements_json}
    - Verbindungen: {connections_json}

    {legend_context}

    **WICHTIG:** Das Debug-Bild zeigt die aktuellen Bounding Boxes und Verbindungen, die die KI erkannt hat. 
    Du musst dieses Bild mit dem Originalbild vergleichen (das im Prompt beschrieben wird).

    **AUFGABE:**
    1. **Vergleiche** das [Debug-Bild] mit dem [Originalbild] (das im Prompt beschrieben wird)
    2. **Identifiziere** alle visuellen Fehler:
       - Fehlende Bounding Boxes (Elemente im Original, aber nicht im Debug-Bild)
       - Falsch gezeichnete Bounding Boxes (zu groß, zu klein, falsche Position)
       - Halluzinierte Elemente (Bounding Boxes im Debug-Bild, aber keine Komponente im Original)
       - Fehlende Verbindungen (Linien im Original, aber nicht im Debug-Bild)
       - Falsche Verbindungen (Linien im Debug-Bild, aber nicht im Original)
    3. **Generiere** Korrekturen als JSON

    **RETURN FORMAT (STRICT JSON):**
    {{
      "visual_errors": [
        {{
          "type": "missing_element",
          "element_id": "P-201",
          "reason": "Element P-201 ist im Originalbild sichtbar, aber nicht im Debug-Bild",
          "suggested_bbox": {{"x": 0.1, "y": 0.2, "width": 0.05, "height": 0.04}}
        }},
        {{
          "type": "hallucinated_element",
          "element_id": "FT-11",
          "reason": "Bounding Box für FT-11 im Debug-Bild, aber keine Komponente an dieser Position im Originalbild"
        }},
        {{
          "type": "wrong_bbox",
          "element_id": "V-01",
          "reason": "Bounding Box zu groß, schließt Text-Label ein",
          "current_bbox": {{"x": 0.3, "y": 0.4, "width": 0.1, "height": 0.1}},
          "corrected_bbox": {{"x": 0.32, "y": 0.42, "width": 0.05, "height": 0.05}}
        }}
      ],
      "corrections": [
        {{
          "action": "add_element",
          "element": {{
            "id": "P-201",
            "type": "Pump",
            "label": "Pump P-201",
            "bbox": {{"x": 0.1, "y": 0.2, "width": 0.05, "height": 0.04}},
            "confidence": 0.9
          }}
        }},
        {{
          "action": "remove_element",
          "element_id": "FT-11",
          "reason": "Halluzination: Keine Komponente an dieser Position"
        }},
        {{
          "action": "resize_bbox",
          "element_id": "V-01",
          "new_bbox": {{"x": 0.32, "y": 0.42, "width": 0.05, "height": 0.05}},
          "reason": "BBox zu groß, schließt Text ein"
        }}
      ],
      "validation_score": 75.0
    }}

    **CRITICAL:** Nur Korrekturen vorschlagen, wenn du dir visuell sicher bist. Wenn du unsicher bist, lasse das Element/Verbindung unverändert.
